// Generated by CoffeeScript 1.8.0
(function() {
  var iio, root, _ref, _ref1, _ref2;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  iio = root.iio = (_ref = root.iio) != null ? _ref : {};

  iio.App = (function() {
    function App(canvas, app, settings) {
      var offset;
      this.canvas = canvas;
      this.type = this.APP;
      this.app = this;
      this.ctx = this.canvas.getContext('2d');
      this.canvas.parent = this;
      iio.canvas.prepInput(this.canvas);
      this.width = this.canvas.clientWidth || this.canvas.width;
      this.height = this.canvas.clientHeight || this.canvas.height;
      this.center = {
        x: this.width / 2,
        y: this.height / 2
      };
      offset = this.canvas.getBoundingClientRect();
      this.pos = {
        x: offset.left,
        y: offset.top
      };
      this.scale = 1;
      this.objs = [];
      this.rqAnimFrame = true;
      this.partialPx = true;
      this.alpha = 1;
      this.loops = [];
      this.run = iio.run;
      this.set = iio.set;
      this.add = iio.add;
      this.rm = iio.rm;
      this.loop = iio.loop;
      this.clearLoops = iio.clearLoops;
      this.pause = iio.pause;
      this.playAnim = iio.playAnim;
      this["eval"] = iio["eval"];
      this.collisions = [];
      iio.apps.push(this);
      if (iio.isString(app)) {
        this.runScript = iio.run(app, this);
        this.draw();
      } else {
        this.runScript = new app(this, settings);
      }
    }

    App.prototype.convertEventPot = function(event) {
      return {
        x: event.clientX - this.pos.x,
        y: event.clientY - this.pos.y
      };
    };

    App.prototype.stop = function() {
      var obj, _i, _len, _ref1;
      _ref1 = this.objs;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        obj = _ref1[_i];
        iio.cancelLoops(obj);
      }
      iio.cancelLoops(this);
      if (this.mainLoop) {
        iio.cancelLoops(this.mainLoop.id);
      }
      return this.clear();
    };

    App.prototype.draw = function(noClear) {
      var obj, _i, _len, _ref1, _results;
      if (!noClear) {
        this.clear();
      }
      if (this.color) {
        this.ctx.fillStyle = this.color;
        this.clear();
      }
      if (this.round) {
        this.canvas.style.borderRadius = round;
      }
      if (this.outline) {
        this.canvas.style.border = "" + (this.lineWidth || 1) + "px solid " + this.outline;
      }
      if (this.alpha) {
        this.canvas.style.opacity = this.alpha;
      }
      _ref1 = this.objs;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        obj = _ref1[_i];
        if (obj.draw) {
          _results.push(obj.draw(this.ctx));
        }
      }
      return _results;
    };

    App.prototype.clear = function() {
      return this.ctx.clearRect(0, 0, this.width, this.height);
    };

    App.prototype.collision = function(object1, object2, callback) {
      return this.collisions.push([object1, object2, func]);
    };

    App.prototype.cCollisions = function(objects1, objects2, callback) {
      var obj1, obj2, _i, _j, _len, _len1;
      if (!(objects1 instanceof Array)) {
        objects1 = [objects1];
      }
      if (!(objects2 instanceof Array)) {
        objects2 = [objects2];
      }
      for (_i = 0, _len = objects1.length; _i < _len; _i++) {
        obj1 = objects1[_i];
        for (_j = 0, _len1 = objects2.length; _j < _len1; _j++) {
          obj2 = objects2[_j];
          if (iio.collision.check(obj1, obj2)) {
            callback(obj1, obj2);
          }
        }
      }
    };

    App.prototype._update = function(obj, dt) {
      var collision, _i, _j, _len, _len1, _ref1, _ref2, _results;
      if (this.update) {
        this.update(dt);
      }
      if (this.objs && this.objs.length > 0) {
        _ref1 = this.objs;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          obj = _ref1[_i];
          if (obj._update && obj._update(obj, dt)) {
            this.rm(obj);
          }
        }
      }
      if (this.collisions && this.collisions.length > 0) {
        _ref2 = this.collisions;
        _results = [];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          collision = _ref2[_j];
          _results.push(this.cCollisions(collision[0], collision[1], collision[2]));
        }
        return _results;
      }
    };

    return App;

  })();

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  iio = root.iio = (_ref1 = root.iio) != null ? _ref1 : {};

  iio.Obj = (function() {
    function Obj(p, s, ss, pp) {
      var _p, _ref2;
      if (pp == null) {
        pp = ss;
      }
      if (pp) {
        this.parent = pp;
        this.app = pp.app;
      }
      if (iio.isString(p)) {
        _p = iio.parsePos(p.split(' '), this.parent);
        p = (_ref2 = _p.ps) != null ? _ref2 : {
          x: 0,
          y: 0
        };
        ss = s;
        s = _p.p;
      }
      if (s == null) {
        s = p;
        p = p.pos;
      }
      p = iio.point.vector(p);
      this.pos = p[0];
      if (p.length === 2) {
        this.type = iio.LINE;
      }
    }

    return Obj;

  })();

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  iio = root.iio = (_ref2 = root.iio) != null ? _ref2 : {};

  Array.prototype.insert = function(index, item) {
    this.splice(index, 0, item);
    return this;
  };

  (function() {
    var type, _i, _len, _ref3;
    this.apps = [];

    /*
    Enums for iio object types
     */
    this.APP = {};
    this.OBJ = {};
    this.LINE = {};
    this.X = {};
    this.CIRC = {};
    this.RECT = {};
    this.POLY = {};
    this.GRID = {};
    this.TEXT = {};

    /*
    Utility functions
     */
    this.addEvent = function(obj, event, callback, capt) {
      if (obj.addEventListener) {
        obj.addEventListener(event, callback, capt);
        return true;
      } else if (obj.attachEvent) {
        obj.attachEvent("on" + event, callback);
        return true;
      } else {
        return false;
      }
    };
    this.set = function(objects, property) {
      var object, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = objects.length; _i < _len; _i++) {
        object = objects[_i];
        _results.push(object.set(property));
      }
      return _results;
    };
    this.cancelLoop = function(l) {
      window.clearTimeout(l);
      return window.cancelAnimationFrame(l);
    };
    this.cancelLoops = function(o, c) {
      var l, obj, _i, _j, _len, _len1, _ref3, _ref4, _results;
      _ref3 = o.loops;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        l = _ref3[_i];
        this.cancelLoop(l.id);
      }
      if (o.mainLoop) {
        this.cancelLoop(o.mainLoop.id);
      }
      if (c == null) {
        _ref4 = o.objs;
        _results = [];
        for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
          obj = _ref4[_j];
          _results.push(this.cancelLoops(obj));
        }
        return _results;
      }
    };
    this.resize = function() {
      var app, _i, _len, _ref3, _results;
      _ref3 = this.apps;
      _results = [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        app = _ref3[_i];
        if (app.canvas.fullscreen) {
          app.width = app.canvas.width = $ ? $(window).width() : window.innerWidth;
          app.height = app.canvas.height = $ ? $(window).height() : window.innerHeight;
        }
        app.center.x = app.canvas.width / 2;
        app.center.y = app.canvas.height / 2;
        if (app.runScript && app.runScript.resize) {
          app.runScript.resize();
        }
        _results.push(app.draw());
      }
      return _results;
    };
    _ref3 = ['Function', 'Number', 'String'];
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      type = _ref3[_i];
      this["is" + type] = function(obj) {
        return toString.call(obj) === ("[object " + type + "]");
      };
    }
    this.isImage = function(imgName) {
      return ['png', 'jpg', 'gif', 'tiff'].some(function(ext) {
        return imgName.indexOf("." + ext) !== -1;
      });
    };
    this.isBetween = function(val, bound1, bound2) {
      return (bound1 <= val && val <= bound2) || (bound2 <= val && val <= bound1);
    };
    this.random = {
      num: function(min, max) {
        min = min != null ? min : 0;
        min = max != null ? max : 1;
        return Math.random() * (max - min) + min;
      },
      int: function(min, max) {
        return Math.floor(this.num(min, max));
      },
      color: function() {
        return "rgb(" + (Math.floor(Math.random() * 255)) + ", " + (Math.floor(Math.random() * 255)) + ", " + (Math.floor(Math.random() * 255)) + ")";
      }
    };
    this.color = {
      random: this.random.color
    };
    this.bounds = {
      resolve: function(b, c) {
        if (b.length > 1) {
          return b[1](c);
        } else {
          return true;
        }
      }
    };
    return this.point = {
      rotate: function(x, y, r) {
        if (r === 0) {
          return {
            x: x,
            y: y
          };
        }
        if (x.x != null) {
          r = y;
          y = x.y;
          x = x.x;
        }
        return {
          x: x * Math.cos(r) - y * Math.sin(r),
          y: y * Math.cos(r) + x * Math.sin(r)
        };
      },
      vector: function(points) {
        var i, vecs, _, _j, _len1;
        if (!(points instanceof Array)) {
          points = [points];
        }
        vecs = [];
        for (i = _j = 0, _len1 = points.length; _j < _len1; i = ++_j) {
          _ = points[i];
          if (points[i].x != null) {
            vecs.push(points[i]);
          } else {
            vecs.push({
              x: points[i],
              y: points[i + 1]
            });
          }
        }
        return vecs;
      }
    };
  }).call(iio);

}).call(this);
