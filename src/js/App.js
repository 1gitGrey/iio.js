// Generated by CoffeeScript 1.9.1
(function() {
  var iio, ref, root;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  iio = root.iio = (ref = root.iio) != null ? ref : {};

  iio.App = (function() {
    function App(canvas, app, settings) {
      var offset;
      this.canvas = canvas;
      this.type = this.APP;
      this.app = this;
      this.ctx = this.canvas.getContext('2d');
      this.canvas.parent = this;
      iio.canvas.prepInput(this.canvas);
      this.width = this.canvas.clientWidth || this.canvas.width;
      this.height = this.canvas.clientHeight || this.canvas.height;
      this.center = {
        x: this.width / 2,
        y: this.height / 2
      };
      offset = this.canvas.getBoundingClientRect();
      this.pos = {
        x: offset.left,
        y: offset.top
      };
      this.scale = 1;
      this.objs = [];
      this.rqAnimFrame = true;
      this.partialPx = true;
      this.alpha = 1;
      this.loops = [];
      this.run = iio.run;
      this.set = iio.set;
      this.add = iio.add;
      this.rm = iio.rm;
      this.loop = iio.loop;
      this.clearLoops = iio.clearLoops;
      this.pause = iio.pause;
      this.playAnim = iio.playAnim;
      this["eval"] = iio["eval"];
      this.collisions = [];
      iio.apps.push(this);
      if (iio.isString(app)) {
        this.runScript = iio.run(app, this);
        this.draw();
      } else {
        this.runScript = new app(this, settings);
      }
    }

    App.prototype.convertEventPot = function(event) {
      return {
        x: event.clientX - this.pos.x,
        y: event.clientY - this.pos.y
      };
    };

    App.prototype.stop = function() {
      var i, len, obj, ref1;
      ref1 = this.objs;
      for (i = 0, len = ref1.length; i < len; i++) {
        obj = ref1[i];
        iio.cancelLoops(obj);
      }
      iio.cancelLoops(this);
      if (this.mainLoop) {
        iio.cancelLoops(this.mainLoop.id);
      }
      return this.clear();
    };

    App.prototype.draw = function(noClear) {
      var i, len, obj, ref1, results;
      if (!noClear) {
        this.clear();
      }
      if (this.color) {
        this.ctx.fillStyle = this.color;
        this.clear();
      }
      if (this.round) {
        this.canvas.style.borderRadius = round;
      }
      if (this.outline) {
        this.canvas.style.border = (this.lineWidth || 1) + "px solid " + this.outline;
      }
      if (this.alpha) {
        this.canvas.style.opacity = this.alpha;
      }
      ref1 = this.objs;
      results = [];
      for (i = 0, len = ref1.length; i < len; i++) {
        obj = ref1[i];
        if (obj.draw) {
          results.push(obj.draw(this.ctx));
        }
      }
      return results;
    };

    App.prototype.clear = function() {
      return this.ctx.clearRect(0, 0, this.width, this.height);
    };

    App.prototype.addCollision = function(object1, object2, callback) {
      return this.collisions.push([object1, object2, callback]);
    };

    App.prototype.checkCollisions = function(objects1, objects2, callback) {
      var i, j, len, len1, obj1, obj2;
      if (!(objects1 instanceof Array)) {
        objects1 = [objects1];
      }
      if (!(objects2 instanceof Array)) {
        objects2 = [objects2];
      }
      for (i = 0, len = objects1.length; i < len; i++) {
        obj1 = objects1[i];
        for (j = 0, len1 = objects2.length; j < len1; j++) {
          obj2 = objects2[j];
          if (iio.collision.check(obj1, obj2)) {
            callback(obj1, obj2);
          }
        }
      }
    };

    App.prototype._update = function(obj, dt) {
      var collision, i, j, len, len1, ref1, ref2, results;
      if (this.update) {
        this.update(dt);
      }
      if (this.objs && this.objs.length > 0) {
        ref1 = this.objs;
        for (i = 0, len = ref1.length; i < len; i++) {
          obj = ref1[i];
          if (obj._update && obj._update(obj, dt)) {
            this.rm(obj);
          }
        }
      }
      if (this.collisions && this.collisions.length > 0) {
        ref2 = this.collisions;
        results = [];
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          collision = ref2[j];
          results.push(this.checkCollisions(collision[0], collision[1], collision[2]));
        }
        return results;
      }
    };

    return App;

  })();

}).call(this);
